#![doc = include_str!("../README.md")]

pub use sys::*;
/// We use the sys module to keep the pre-generated and build-time-generated bindings
/// separated from each other.
#[cfg(not(feature = "bindgen"))]
mod sys {
    /// if `bindgen` feature is not enabled, we use manually maintained bindings
    /// for native handles stuff.
    mod manual;
    /// if `bindgen` is not enabled, we use pre-generated bindings.
    mod pregenerated;

    #[allow(
        unused_imports,
        reason = "on emscripten target, this module will be empty"
    )]
    pub use self::manual::*;
    pub use self::pregenerated::*;
}
/// This module contains bindings generated by `bindgen` during build time.
#[cfg(feature = "bindgen")]
mod sys {
    #![allow(
        unused,
        non_upper_case_globals,
        non_camel_case_types,
        non_snake_case,
        improper_ctypes,
        rustdoc::invalid_codeblock_attributes,
        rustdoc::invalid_rust_codeblocks,
        rustdoc::broken_intra_doc_links,
        reason = "
        This is a bindgen generated file from C headers and can't be fixed manually.
        It contains all sorts of code (and other blocks). The [] link syntax is used for
        @param[in] arg syntax, so links are also broken.
        "
    )]
    // if bindings is enabled, we use bindgen to generate bindings and include them here
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// This is a hack to ensure that glfw sources are included when we publish the crate.
/// If we forgot to recursively clone the submodule and call cargo publish,
/// this will fail to build due to missing path to header.
///
/// We support building from source, so, we need to bundle the sources
/// with the crate.
#[allow(unused)]
const GLFW_HEADER: &str = include_str!("../glfw/include/GLFW/glfw3.h");
